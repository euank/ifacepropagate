package main

import (
	"bytes"
	"fmt"
	"go/types"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

func usage() {
	fmt.Fprintf(os.Stderr, `Usage:
igen [package] [xxx] ...
`)
}

func main() {
	args := os.Args

	if len(args) != 4 {
		usage()
		os.Exit(1)
	}
	pkgSel, ifaceSel, ifacesList := args[1], args[2], args[3]
	ifaces := strings.Split(ifacesList, ",")

	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedTypes | packages.NeedName | packages.NeedSyntax | packages.NeedImports,
	}, pkgSel)
	if err != nil {
		log.Fatalf("error loading pkg %q: %v", pkgSel, err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("multiple packages found, but we needed to load only one package: %v", pkgs)
	}

	pkg := pkgs[0]
	// And now find the desired iface
	ifaceParts := strings.Split(ifaceSel, ".")
	if len(ifaceParts) != 2 {
		log.Fatalf("format for the struct selector must be 'struct.Member', was %v", ifaceSel)
	}
	obj := pkg.Types.Scope().Lookup(ifaceParts[0])
	if obj == nil {
		log.Fatalf("pkg %v didn't contain a type named %v", pkgSel, ifaceParts[0])
	}
	member, _, _ := types.LookupFieldOrMethod(obj.Type(), false, obj.Pkg(), ifaceParts[1])
	if member == nil {
		log.Fatalf("object %v in pkg %v didn't contain a member named %v", ifaceParts[0], pkgSel, ifaceParts[1])
	}
	typ := member.Type()
	if !types.IsInterface(typ) {
		log.Fatalf("member must be an iface")
	}
	// Okay, cool, time to get cracking!
	// We could also validate that the interfaces specified in 'ifaces' exist,
	// but let's just trust in our caller to have gotten it right.

	interfaceImports := make([]string, 0, len(ifaces))
	for _, iface := range ifaces {
		if s, ok := interfaceSpecImport(iface); ok {
			interfaceImports = append(interfaceImports, s)
		}
	}
	// TODO: uniq interfaceImports

	var code bytes.Buffer

	code.WriteString(fmt.Sprintf(`
// Generated by igen %s
package %s

`, strings.Join(args, " "), pkg.Name))

	if len(interfaceImports) != 0 {
		importStrs := make([]string, 0, len(interfaceImports))
		for _, imp := range interfaceImports {
			importStrs = append(importStrs, `"`+imp+`"`)
		}

		code.WriteString(`import (
	` + strings.Join(importStrs, "\n") + `
)

`)
	}

	// And now the interface propogation function

	code.WriteString(`func (s ` + ifaceParts[0] + `) propogateInterfaces() ` + typ.String() + ` {
`)

	for idx, iface := range ifaces {
		code.WriteString(fmt.Sprintf("\t_, i%d := s.(%s)\n", idx, iface))
	}
	// And now all combinations
	conditions := conditionPermutations(ifaces)
	code.WriteString("\n")

	code.WriteString("\tswitch {\n")
	for cond, ifaces := range conditions {
		code.WriteString(fmt.Sprintf("\tcase %s:", cond))
		// In this case, it implements the ifaces in ifaces, create a struct to
		// mask out anything else
		code.WriteString(fmt.Sprintf(`
		return struct {
			%s
			%s
		}{%s}
`, typ.String(), strings.Join(ifaces, "\n\t"), strings.Join(repeat("s", len(ifaces)+1), ", ")))
	}
	code.WriteString(`	default:
		panic("unreachable")
	}
}
`)
	fmt.Println(code.String())
}

func repeat(s string, num int) []string {
	a := make([]string, 0, num)
	for i := 0; i < num; i++ {
		a = append(a, s)
	}
	return a
}

func conditionPermutations(ifaces []string) map[string][]string {
	numPerms := 2 << (len(ifaces) - 1)
	result := make(map[string][]string, numPerms)
	for perm := numPerms - 1; perm >= 0; perm-- {
		conditionParts := make([]string, 0, len(ifaces))
		enabledIfaces := make([]string, 0, len(ifaces))
		for i, iface := range ifaces {
			varName := fmt.Sprintf("i%d", i)
			if perm>>i&0x1 == 1 {
				conditionParts = append(conditionParts, varName)
				enabledIfaces = append(enabledIfaces, iface)
			} else {
				conditionParts = append(conditionParts, "!"+varName)
			}
		}
		result[strings.Join(conditionParts, " && ")] = enabledIfaces
	}
	return result
}

func interfaceSpecImport(spec string) (string, bool) {
	lastDot := -1
	for i, c := range spec {
		if string(c) == "." {
			lastDot = i
		}
	}
	if lastDot != -1 {
		return spec[:lastDot], true
	}
	return "", false
}
